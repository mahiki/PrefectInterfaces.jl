var documenterSearchIndex = {"docs":
[{"location":"prefect/install-local-prefect-environment/#Prefect-Installation","page":"Prefect Install","title":"Prefect Installation","text":"","category":"section"},{"location":"prefect/install-local-prefect-environment/","page":"Prefect Install","title":"Prefect Install","text":"This local install environment is managed by Poetry, ensuring isolation from other python environments. These are the instructions to install a local Prefect instance for package testing, demonstration, or even as a lightweight local workflow orchestration tool. Prefect provides a command-line interface and python SDK.","category":"page"},{"location":"prefect/install-local-prefect-environment/","page":"Prefect Install","title":"Prefect Install","text":"This prefect/ folder holds all the configuration for installing a small Prefect DB (which is a sqlite file stored in the PREFECT_HOME directory).","category":"page"},{"location":"prefect/install-local-prefect-environment/#Justfile","page":"Prefect Install","title":"Justfile","text":"","category":"section"},{"location":"prefect/install-local-prefect-environment/","page":"Prefect Install","title":"Prefect Install","text":"We use justfile. It is convenient to manage development tasks like starting/stopping the server with a task runner of some sort. The just commands inject the necessary environment variables (from .env) and provides a self-documenting scripting tool.","category":"page"},{"location":"prefect/install-local-prefect-environment/","page":"Prefect Install","title":"Prefect Install","text":"Find paralled installation instructions that eschew just in Install Prefect Environment - Poetry Commands.","category":"page"},{"location":"prefect/install-local-prefect-environment/#Install-Prefect-(Macos)","page":"Prefect Install","title":"Install Prefect (Macos)","text":"","category":"section"},{"location":"prefect/install-local-prefect-environment/","page":"Prefect Install","title":"Prefect Install","text":"If you don't already have a Prefect Server or Cloud instance running, you'll need to install one locally to test out the Julia PrefectInterfaces functionality.","category":"page"},{"location":"prefect/install-local-prefect-environment/","page":"Prefect Install","title":"Prefect Install","text":"!!! note \"Prefect Install Dependencies     * pipx, to install poetry     * python3     * tmux     * git     * poetry","category":"page"},{"location":"prefect/install-local-prefect-environment/","page":"Prefect Install","title":"Prefect Install","text":"Commands below are on macOS, should be the same on linux except for open.  The dependency installation will be different depending on your linux distribution.","category":"page"},{"location":"prefect/install-local-prefect-environment/","page":"Prefect Install","title":"Prefect Install","text":"Open a Terminal window:","category":"page"},{"location":"prefect/install-local-prefect-environment/","page":"Prefect Install","title":"Prefect Install","text":"$ brew install pipx just python@3 git tmux\n\npipx install poetry\n\ngit clone https://github.com/mahiki/PrefectInterfaces.jl PrefectInterfaces\n\ncd PrefectInterfaces/prefect\n\n# This script configures and initializes the local Prefect server.\njust init","category":"page"},{"location":"prefect/install-local-prefect-environment/","page":"Prefect Install","title":"Prefect Install","text":"The poetry/prefect environment should be installed now, and a prefect server running in a tmux session. You should be able to interact with it using the prefect CLI, the python API, or the Julia commands in the Julia Demo section.  Remember the environment is managed by Poetry so every CLI Prefect command needs to be prefixed: poetry run prefect blocks ls. The just pre command inserts poetry run prefect for you, and all just commands also inject the very important PREFECT_PROFILES_PATH and other env variables.","category":"page"},{"location":"prefect/install-local-prefect-environment/","page":"Prefect Install","title":"Prefect Install","text":"$ tmux ls\n#   pi-main: 1 windows\n\njust ls\n#                                                  Blocks\n# ┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n# ┃ ID                                   ┃ Type              ┃ Name        ┃ Slug                         ┃\n# ┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n# │ 39c985b0-149c-4b66-886f-6d2fb773ff49 │ Local File System │ willowdata  │ local-file-system/willowdata │\n# │ db021ae5-826b-4fe6-8ac4-9ece159658bf │ Secret            │ necromancer │ secret/necromancer           │\n# │ 41636ef0-8e76-4f85-b3b7-cbcec0518faf │ String            │ syrinx      │ string/syrinx                │\n# └──────────────────────────────────────┴───────────────────┴─────────────┴──────────────────────────────┘\n\n\n# examine the contents of the two prefect blocks in the db\njust pre block inspect string/syrinx\n#                                    string/syrinx\n# ┌───────────────────────────────────────────┬──────────────────────────────────────┐\n# │ Block Type                                │ String                               │\n# │ Block id                                  │ a3de68af-c74b-40e5-9213-716b1b051dd1 │\n# ├───────────────────────────────────────────┼──────────────────────────────────────┤\n# │ value                                     │ main                                 │\n# └───────────────────────────────────────────┴──────────────────────────────────────┘\n\njust pre block inspect local-file-system/willowdata\n\n# open the tmux window, a prefect server and agent are running\njust view main\n\n# exit tmux with CTRL-b, d\n\n# examine the env variables injected by just commands\njust env\n\n# set the Prefect profile (thus PREFECT_HOME, PREFECT_API_URL) for desired environment.\njust use main\n\n# to close out the prefect server\njust kill","category":"page"},{"location":"prefect/install-local-prefect-environment/","page":"Prefect Install","title":"Prefect Install","text":"note: Dashboard Local URL\nA nice dashboard should be available locally on a browser here: http://127.0.0.1:4300","category":"page"},{"location":"prefect/install-local-prefect-environment/","page":"Prefect Install","title":"Prefect Install","text":"","category":"page"},{"location":"prefect/install-local-prefect-environment/","page":"Prefect Install","title":"Prefect Install","text":"Next Steps: Julia Demo","category":"page"},{"location":"prefect/setup-without-justfile/#Install-Prefect-Environment-Poetry-Commands","page":"Manual Install","title":"Install Prefect Environment - Poetry Commands","text":"","category":"section"},{"location":"prefect/setup-without-justfile/","page":"Manual Install","title":"Manual Install","text":"This is the same as the Prefect Installation, without using the justfile taskrunner. It makes the relationship between env variables and Prefect DB location and API more explicit.","category":"page"},{"location":"prefect/setup-without-justfile/","page":"Manual Install","title":"Manual Install","text":"brew install pipx just python@3\npipx install poetry\n\ngit clone https://github.com/mahiki/PrefectInterfaces.jl PrefectInterfaces\n\ncd PrefectInterfaces/prefect\n\npoetry env use 3.11\npoetry install\n\n# open a new terminal to run the prefect server\nexport PREFECT_HOME=./prefecthome\nexport PREFECT_SERVER_API_PORT=\"4300\"\nexport PREFECT_PROFILES_PATH=\"./profiles.toml\"\npoetry run prefect server start","category":"page"},{"location":"prefect/setup-without-justfile/","page":"Manual Install","title":"Manual Install","text":"note: Dashboard Local URL\nA nice dashboard should be available locally on a browser here: http://127.0.0.1:4300","category":"page"},{"location":"prefect/setup-without-justfile/","page":"Manual Install","title":"Manual Install","text":"Now initialize the Prefect environment by registering some Blocks. We can establish a \"main\" and \"dev\" environment by starting another prefect server at a different PREFECT_SERVER_API_PORT and PREFECT_HOME.","category":"page"},{"location":"prefect/setup-without-justfile/","page":"Manual Install","title":"Manual Install","text":"Back to the first terminal session in PrefectInterfaces/prefect folder.","category":"page"},{"location":"prefect/setup-without-justfile/","page":"Manual Install","title":"Manual Install","text":"export PREFECT_HOME=./prefecthome\nexport PREFECT_API_URL=\"http://127.0.0.1:4300/api\"\nexport PREFECT_PROFILES_PATH=\"./profiles.toml\"\n\n# register some blocks\nPREFECT_ENV=\"main\" poetry run prefect block register --file src/blocks/str_prefect_env.py\npoetry run prefect block register --file src/blocks/fs_willowdata.py\npoetry run prefect block register --file src/blocks/secret_necromancer.py","category":"page"},{"location":"prefect/setup-without-justfile/","page":"Manual Install","title":"Manual Install","text":"You should now be able to see the registered blocks, and settings in the Dashboard UI:","category":"page"},{"location":"prefect/setup-without-justfile/","page":"Manual Install","title":"Manual Install","text":"http://127.0.0.1:4300/blocks","category":"page"},{"location":"prefect/setup-without-justfile/","page":"Manual Install","title":"Manual Install","text":"http://127.0.0.1:4300/settings","category":"page"},{"location":"prefect/setup-without-justfile/","page":"Manual Install","title":"Manual Install","text":"# from the command line you can list the blocks and inspect them.\npoetry run prefect block ls\n13:20:59.049 | DEBUG   | prefect.profiles - Using profile 'main'\n13:20:59.636 | DEBUG   | prefect.client - Connecting to API at http://127.0.0.1:4300/api/\n                                                 Blocks\n┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓\n┃ ID                                   ┃ Type              ┃ Name        ┃ Slug                         ┃\n┡━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┩\n│ 39c985b0-149c-4b66-886f-6d2fb773ff49 │ Local File System │ willowdata  │ local-file-system/willowdata │\n│ db021ae5-826b-4fe6-8ac4-9ece159658bf │ Secret            │ necromancer │ secret/necromancer           │\n│ 41636ef0-8e76-4f85-b3b7-cbcec0518faf │ String            │ syrinx      │ string/syrinx                │\n└──────────────────────────────────────┴───────────────────┴─────────────┴──────────────────────────────┘\n                             List Block Types using `prefect block type ls`\n\npoetry run prefect profiles inspect main\n    # PREFECT_LOGGING_LEVEL='INFO'\n    # PREFECT_SERVER_API_PORT='4300'\n    # PREFECT_API_URL='http://127.0.0.1:4300/api'\n\n# also, see all the available prefect CLI commands:\npoetry run prefect --help","category":"page"},{"location":"usage-and-explanation/#Usage-and-Design-Explanation","page":"Detailed Explanation","title":"Usage and Design Explanation","text":"","category":"section"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"A Data Scientist or Analyst User Story","category":"page"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"The problem is to manage routine data ETL or pipeline processing with Prefect and the Python API, while calling Julia fuctions for expressive dataframe transformations or niche high performance custom code. Prefect doesn't provide a Julia SDK (yet), so this package provides components for julia operations that are called from a Prefect orchestration environment. ","category":"page"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"Prefect python flows will call Julia DockerContainer or ShellOperations with parameters such as {dataset_name: \"my_great_dataset\", datastore_type: \"remote\"}. This isolates the julia environment from the Python one, and avoids sending large data objects through function calls to/from Prefect flows.","category":"page"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"This strategy also avoids pythoncall/juliacall interoperation, a cool paradigm but one which requires combined python Conda + julia environment management, which is difficult in Prefect deployments. The other side of the coin is that the Julia process needs to define parallel functionality to match the Prefect python application. For example, PrefectBlock(\"s3-bucket/willowdata\") which loads block information about \"s3-bucket/willowdata\" from the Prefect server endpoint, or PrefectInterfaces.Dataset, which defines a structure for organising input/output/intermediate data file locations to match a similar one in a Prefect application. Accessing block information by name from the julia process greatly simplifies the overall application and reuses the modular paradigm provided by Prefect Blocks.","category":"page"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"So now we can orchestrate simple SQL query extracts and data pipelines using the Prefect Python SDK, writing intermediate or final results to a DB or filesystem, and then access these from a julia process using parameters, and references to the same Blocks stored in the Prefect DB. The julia process is orchestrated from Prefect via flow calls to ShellOperation or DockerContainer. By way of an example implementation, the julia process will read data specified by a Dataset instance, and write output to Dataset defined locations. This example imaginess a similar Dataset class defined in the main python application, it's also an example of the code duplication trade-off mentioned above.","category":"page"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"┌─────────────┐                   ┌─────────────┐◄───── read ────── ┌───────────┐\n│Prefect flow ├────► params ─────►│Julia process├─────► write ────► │file Block │\n└─────────────┘                   └─────────────┘                   └───────────┘","category":"page"},{"location":"usage-and-explanation/#Who-Would-Want-This?","page":"Detailed Explanation","title":"Who Would Want This?","text":"","category":"section"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"One who wants deploy some julia process into a production environment orchestrated by Prefect.","category":"page"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"The use-case is for scientists or analysts who use Julia and orchestrate data tasks with Prefect. Science and analyst workflows are multi-stage affairs and orchestration is the best solution to managing a proliferation of scheduled jobs. Crucially, the researcher doesn't need or want to set up a production data engineering platform (DBT, Snowflake, Databricks, Azure Data Lake, etc.); this package imagines a very lightweight coder experience. Prefect flows in python are easily understood and quickly deployed (even just locally), and very usable at the individual adhoc level all the way up to large team production environment.","category":"page"},{"location":"usage-and-explanation/#Dataset","page":"Detailed Explanation","title":"Dataset","text":"","category":"section"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"This is a concrete example of code defined in your Prefect python application that would need a parallel defition in your julia application. This composite type holds metadata that represents where a data artifact would be written to or read from, and allows a data product to be referenced by a dataset_name. The Dataset keeps track of file paths and partitions (rundate). Other partitions could be implemented, even a Spark/Apache Hive compliant design, if you are a data engineer that likes julia.","category":"page"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"Imagine a Prefect flow that reads/writes to locations defined by a python Dataset class. When calling a julia process with instructions to read Dataset(dataset_name=\"my_cool_dataset\") the prefect flow provides parameters sufficient to construct the Dataset instance in the julia process, and the remaining required information is the Prefect server API and names of Prefect blocks required to complete the job. These blocks may define local or remote file systems, details are pulled from the Prefect API endpoint via the PrefectBlock(blockname::String) function. The datastore is conceived here as an organized set of files in a Apache hive-ish layout.","category":"page"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"$HOME/willowdata/projectname/dev/extracts\n└── csv\n    ├── dataset=my_cool_dataset\n    │   ├── rundate=2022-10-23\n    │   │   └── data.csv\n    │   └── rundate=2022-10-30\n    │       └── data.csv\n    ├── latest\n    │   └── dataset=my_cool_dataset\n    │       └── data.csv","category":"page"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"As a data scientist, it is convenient to reference copious adhoc data artificts by name and let a lightweight orchestration application figure out where to keep it.","category":"page"},{"location":"usage-and-explanation/#Package-Details","page":"Detailed Explanation","title":"Package Details","text":"","category":"section"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"Interacts with the Prefect Server API to get block information for read/writes, credentials, filesystems, etc.\nThe PrefectBlock(blockname::String) function requires that a Prefect Server is running, and server endpoint is provided via env variable PREFECT_API_URL or a url as keyword argument.\nA good way is to use the .env file to specify configuration such as local/remote with a call to ConfigEnv.dotenv()","category":"page"},{"location":"usage-and-explanation/#Development-And-Production-Environments","page":"Detailed Explanation","title":"Development And Production Environments","text":"","category":"section"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"Prefect profiles are good for separating prod/dev/test environments, for convenience from the Prefect CLI. Ultimately the API URL defines which Prefect environment you are in. It's useful for these to correspond to git branches. ","category":"page"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"The julia environment does not need to be aware of project environment, because it will pull all required information from blocks accessed via each environment's PREFECTAPIURL. For example, in the Prod environment an S3 bucket key \"willowdata/prod\" would be defined in the s3-bucket block. The julia application pulls the s3 bucket and key from block information and otherwise executes in the same way for each environment.","category":"page"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"Managing dev/prod environment with dev/main git branches: When both main/dev are local, there will be two local prefect DB with different PREFECTAPIURL defined by the Prefect profiles.toml profile. The python side of the application will need to distinguish the dev/prod PREFECT_HOME environment variables to define different locations for the prefect DB (which is just a sqlite file). I prefer to do this in a task runner outside of the python application, something like Github Actions, Make, or just.","category":"page"},{"location":"usage-and-explanation/#Justfile","page":"Detailed Explanation","title":"Justfile","text":"","category":"section"},{"location":"usage-and-explanation/","page":"Detailed Explanation","title":"Detailed Explanation","text":"I've found when managing a Prefect orchestrator it is helpful to have a taskrunner program that documents development tasks and executes them for you as well. I use just to launch dev/main Prefect DB local servers and manage tasks like Prefect deployment builds ßand running tests before merging and deploying. If you, like most data scientists, like to develop and test on the main branch please ignore this part of the package.","category":"page"},{"location":"julia-demo/#Julia-Demo","page":"Demonstration","title":"Julia Demo","text":"","category":"section"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"This demonstrates interacting with a running Prefect DB from the Julia REPL. If you don't have a Prefect Server instance running, see the Prefect Installation doc first. Block information is usually pulled from the Prefect DB, but Prefect Block types can also be manually created from the constructors.","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"See files in the test folder for examples of Block usage and loading data from Prefect DB, some require the Prefect DB to run and some tests simply construct dummy objects without connecting to Prefect.","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"Entering the Julia REPL from the just julia command will inject the .env variables. Execute the just commands from the appropriate directory as shown.","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"$ cd ./prefect/\n$ just launch\n\n    # to verify server is running, and the API PORT:\n    just view main\n    # CTRL-b, d to exit\n\n$ cd ../julia-demo\n\n# start julia in current project, env vars will be loaded as well\n$ just julia","category":"page"},{"location":"julia-demo/#Examples","page":"Demonstration","title":"Examples","text":"","category":"section"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"Call the PrefectAPI function\nAccess the secret string in an AWS Credentials block via .secret field","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"julia> using PrefectInterfaces\n\n# returns the current endpoint from env\nPrefectAPI().url\n    # \"http://127.0.0.1:4300/api\"\n\n# PrefectAPI is called by various functions to retreive the current API env value\nENV[\"PREFECT_API_URL\"] = \"http://127.0.0.1:4301/api\";\nPrefectAPI().url\n    # \"http://127.0.0.1:4301/api\"\n\n# Construct an example, normally this is pulled from DB if such a block \n#   exists with PrefectBlock(\"aws-credentials/subdivisions\")\ncreds = AWSCredentialsBlock(\n    \"aws-credentials/subdivisions\"\n    , \"aws-credentials\"\n    , \"us-west-2\"\n    , \"AKIAXXX999XXX999\"\n    , \"GUUxx87987xxPXH\")\n    # AWSCredentialsBlock(\"aws-credentials/subdivisions\", \"aws-credentials\", \"us-west-2\", \"AKIAXXX999XXX999\", ####Secret####)\n\ncreds.aws_secret_access_key\n    # ####Secret####\n\ncreds.aws_secret_access_key.secret\n    # \"GUUxx87987xxPXH\"","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"The secret is obfuscated, to prevent it being visible in logs. ","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"There are other AbstractPrefectBlock types, see list below. These facilitate interactions with Blocks in your Prefect instance, they are primary organizing abstractions in the Prefect world.","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"julia> names(PrefectInterfaces);\nsubtypes(PrefectInterfaces.AbstractPrefectBlock)\n    #    AWSCredentialsBlock\n    #    CredentialPairBlock\n    #    LocalFSBlock\n    #    PrefectBlock\n    #    S3BucketBlock\n    #    StringBlock\n    #    SecretBlock","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"Shut down the server after exiting julia.","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"$ cd ../prefect\n$ just kill","category":"page"},{"location":"julia-demo/#Dataset-Type","page":"Demonstration","title":"Dataset Type","text":"","category":"section"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"This type is an opinionated means of organizing data artifacts by name.  This is not a part of the Prefect API, and can be disregarded. Dataset is not a dependency of the Prefect types that are meant to constitute an unofficial 'Prefect Julia SDK'.","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"This is a lightweight organizational construct for reading/writing data artifacts as a part of orchestrated data pipelines. The type merely holds metadata about named data sets and where they should be found or placed in a file system that is defined by a Prefect Block. The data files get arranged in a hive-ish file structure that allows tracking experiment results or daily extracts. The layout assumes partitions of daily data, additing additional partitions to the struct definition wouldn't be difficult.","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"The fields of the Dataset type are populated by env variables (loaded from a .env file) or defined in the constructor. The env variables PREFECT_DATA_BLOCK_REMOTE, PREFECT_DATA_BLOCK_LOCAL are used by the PrefectDatastoreNames() to return the names of your Prefect blocks which define remote or local storage.","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"ENV[\"PREFECT_API_URL\"] = \"http://127.0.0.1:4300/api\"\nENV[\"PREFECT_DATA_BLOCK_LOCAL\"] = \"local-file-system/willowdata\"\nENV[\"PREFECT_DATA_BLOCK_REMOTE\"] = \"local-file-system/willowdata\"   \n     # NOTE: defining the same, unless you have a remote storage block registered\n\nds = Dataset(dataset_name=\"limelight_moving_pictures\", datastore_type=\"local\")\n\nusing DataFrames\ndf = DataFrame(\n    flag = [false, true, false, true, false, true]\n    , amt = [19.00, 11.00, 35.50, 32.50, 5.99, 5.99]\n    , qty = [1, 4, 1, 3, 21, 109]\n    , item = [\"B001\", \"B001\", \"B020\", \"B020\", \"BX00\", \"BX00\"]\n    , day = [\"2021-01-01\", \"2021-01-01\", \"2112-12-12\", \"2020-10-20\", \"2021-05-04\", \"1984-07-04\"]\n    );\n\nwrite(ds, df)\n    #  \"$HOME/willowdata/main/extracts/csv/latest/dataset=limelight_moving_pictures/data.csv\"\n    #  \"$HOME/willowdata/main/extracts/csv/dataset=limelight_moving_pictures/rundate=2023-08-14/data.csv\"\n\ndfr = read(ds)\n    # 6×5 DataFrame\n    #  Row │ flag   amt      qty    item     day\n    #  ... etc","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"The read and write functions are calling the Prefect Server API to retrieve block information, in this case the LocalFilesystem.basepath attribute.","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"Notice the write function writes to two locations unless rundate_type=\"specific\". This is for the use-case of running a backfill of historical daily data without affecting the 'latest' path. The 'latest' folder is a convenience rather than creating a module that reads file metdata.","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"tree $HOME/willowdata/main/extracts\n$HOME/willowdata/main/extracts\n└── csv\n    ├── dataset=limelight_moving_pictures\n    │   └── rundate=2023-08-14\n    │       └── data.csv\n    └── latest\n        └── dataset=limelight_moving_pictures\n            └── data.csv","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"Reading/writing a specific rundate:","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"# writing a specific rundate\nds1 = Dataset(dataset_name=\"test_dataset_specific\", datastore_type=\"local\", rundate=Date(\"2112-03-15\"))\n    # Dataset\n    #   dataset_name: String \"test_dataset_specific\"\n    #   datastore_type: String \"local\"\n    #   dataset_type: String \"extracts\"\n    #   file_format: String \"csv\"\n    #   rundate: Date\n    #   rundate_type: String \"specific\"\n    #   dataset_path: String \"extracts/csv/dataset=test_dataset_specific/rundate=2112-03-15/data.csv\"\n    #   latest_path: String \"extracts/csv/latest/dataset=test_dataset_specific/data.csv\"\n    #   image_path: String \"extracts/dataset=test_dataset_specific/rundate=2112-03-15\"\n\nwrite(ds1, df)\n    #  \"$HOME/willowdata/main/extracts/csv/dataset=test_dataset_specific/rundate=2112-03-15/data.csv\"\n\n# note only one path was written. the 'latest_path' was not.\nshell> ls -la \"$HOME/willowdata/main/$(ds1.latest_path)\"\n    # ls: cannot access '$HOME/willowdata/main/extracts/csv/latest/dataset=test_dataset_specific/data.csv': No such file or directory\n\nshell>  ls -la \"$HOME/willowdata/main/$(ds1.dataset_path)\"\n    # -rw-r--r-- 1 segovia staff 196 Aug 14 15:45 '$HOME/willowdata/main/extracts/csv/dataset=test_dataset_specific/rundate=2112-03-15/data.csv'\n\n# the 'read' function knows to read the correct path\ndf1 = read(ds1);\n\ndf1 == dfr\n    # true","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"The datastore now looks like this:","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"/Users/segovia/willowdata/main/extracts/\n└── csv\n    ├── dataset=test_dataset_specific\n    │   └── rundate=2112-03-15\n    │       └── data.csv\n    ├── dataset=limelight_moving_pictures\n    │   └── rundate=2023-08-14\n    │       └── data.csv\n    └── latest\n        └── dataset=limelight_moving_pictures\n            └── data.csv","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"","category":"page"},{"location":"julia-demo/#Environment","page":"Demonstration","title":"Environment","text":"","category":"section"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"note: A Note about ENV\nThe Prefect types pull information from a running Prefect DB, by calling the REST API stored in PREFECTAPIURL. If the julia REPL session is called from a just command, the .env variables will be exported into the environment. In application code you need to either set ENV[\"PREFECT_API_URL\"]=\"http://127.0.0.1:4300/api\" (for example) or use the ConfigEnv package as shown below to load the .env file from the Julia application.","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"The Dataset read/write functions depend on the local and remote data block names being defined in environment variables.","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"# .env file imported with ConfigEnv.dotent(), or just assignment:\nusing ConfigEnv\ndotenv(\".env\", overwrite=false)\n\n# all the Prefect env variables are now loaded into the Julia environment\nENV[\"PREFECT_DATA_BLOCK_REMOTE\"]\n    # \"s3-bucket/willowdata\"\n\n# or just set them manually\nbegin\n    ENV[\"PREFECT_API_URL\"] = \"http://127.0.0.1:4300/api\"\n    ENV[\"PREFECT_DATA_BLOCK_LOCAL\"] = \"local-file-system/willowdata\"\n    ENV[\"PREFECT_DATA_BLOCK_REMOTE\"] = \"s3-bucket/willowdata\"\nend","category":"page"},{"location":"julia-demo/","page":"Demonstration","title":"Demonstration","text":"For interactive work, entering the Julia REPL from the just julia command will inject the .env variables.","category":"page"},{"location":"#PrefectInterfaces.jl","page":"Introduction","title":"PrefectInterfaces.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"May the Prefect Julia SDK arrive soon.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"You prefer to analyze and wrangle data in Julia, and you orchestrate your data workflows with Prefect (in python), this project helps you bring those together.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"PrefectInterfaces.jl helps you integrate Julia operations into a Prefect orchestration environment. Julia functions call your Prefect instance (Server or Cloud) and pull block information including secrets. Now you can use Prefect python flows to call your Julia process via DockerContainer or ShellOperation and deploy these in the normal way. The Julia process has access to resources and can read/write in the same environment as the rest of your orchestration code.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Included in the package is a bootstrapped installation of a local Prefect instance, and an example Dataset type to demonstrate a concrete use-case.","category":"page"},{"location":"#Installation","page":"Introduction","title":"Installation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Requires a Prefect Instance\nTo use most functionality, a Prefect server/cloud instance must be available. Provide the API endpoint via environment variable PREFECT_API_URL or set the definition within julia application code.See Prefect Installation to quickly launch a local Prefect server.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"julia> Pkg.add(\"PrefectInterfaces\")","category":"page"},{"location":"#Usage","page":"Introduction","title":"Usage","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"List available Prefect blocks\nLoad a secret from the Prefect DB\nLoad a local file system block from Prefect DB\nUse the read_path, write_path methods from the FS Block.\nNotice the block implements a base path","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"note: Read/Write Assumes CSV Data\nread_path/write_path, and also the Dataset read/write methods, currently support read/read via CSV module. In the future this should be refactored to handle any type of file.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# provide a reference to the running Prefect REST API\njulia> ENV[\"PREFECT_API_URL\"] = \"http://127.0.0.1:4300/api\"\n\nusing PrefectInterfaces\n\ndb = ls();\ndb.blocks\n    # 3-element Vector{String}:\n    #  \"local-file-system/willowdata\"\n    #  \"secret/necromancer\"\n    #  \"string/syrinx\"\n\nsecret_block = PrefectBlock(\"secret/necromancer\")\n# PrefectBlock(\"secret/necromancer\", Main.PrefectInterfaces.SecretBlock(\"secret/necromancer\", \"secret\", ####Secret####))\n\nsecret_block.block.value\n    #  ####Secret####\n\nsecret_block.block.value.secret\n    # \"abcd1234\"\n\nusing DataFrames\ndf = DataFrame(\n    flag = [false, true, false, true, false, true]\n    , amt = [19.00, 11.00, 35.50, 32.50, 5.99, 5.99]\n    , qty = [1, 4, 1, 3, 21, 109]\n    , item = [\"B001\", \"B001\", \"B020\", \"B020\", \"BX00\", \"BX00\"]\n    , day = [\"2021-01-01\", \"2021-01-01\", \"2112-12-12\", \"2020-10-20\", \"2021-05-04\", \"1984-07-04\"]\n    );\n\nfs_block = PrefectBlock(\"local-file-system/willowdata\");\ndump(fs_block)\n    # PrefectBlock\n    #   blockname: String \"local-file-system/willowdata\"\n    #   block: LocalFSBlock\n    #     blockname: String \"local-file-system/willowdata\"\n    #     blocktype: String \"local-file-system\"\n    #     basepath: String \"$HOME/willowdata/main\"\n    #     read_path: #4 (function of type PrefectInterfaces.var\"#4#6\"{String})\n    #       basepath: String \"$HOME/willowdata/main\"\n    #     write_path: #5 (function of type PrefectInterfaces.var\"#5#7\"{String})\n    #       basepath: String \"$HOME/willowdata/main\"\n\ndatafile = fs_block.block.write_path(\"csv/dataset=test_block_write/data.csv\", df)\n    # \"$HOME/willowdata/main/csv/dataset=test_block_write/data.csv\"\n\nisfile(datafile)\n    # true\n\ndf2 = fs_block.block.read_path(\"csv/dataset=test_block_write/data.csv\")\n    # 6×5 DataFrame\n    #  Row │ flag   amt      qty    item     day\n    #      │ Bool   Float64  Int64  String7  Date\n    # ─────┼────────────────────────────────────────────\n    #    1 │ false    19.0       1  B001     2021-01-01\n    #    2 │  true    11.0       4  B001     2021-01-01\n    #    3 │ false    35.5       1  B020     2112-12-12\n    #    4 │  true    32.5       3  B020     2020-10-20\n    #    5 │ false     5.99     21  BX00     2021-05-04\n    #    6 │  true     5.99    109  BX00     1984-07-04","category":"page"},{"location":"#Datasets","page":"Introduction","title":"Datasets","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"On top of the Prefect API, this package includes a Datasets module that reads/writes dataframes to file locations based only on the name you give to the data artifact, see Dataset Type.","category":"page"},{"location":"#Calling-From-Prefect-Flow","page":"Introduction","title":"Calling From Prefect Flow","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"The one thing the Julia process will need from the prefect flow is the PREFECTAPIURL. This is accessible from your Prefect python application code via settings. The call to Julia code is via ShellOperation or Docker container.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"# Python\nfrom prefect import flow\nfrom prefect_shell import ShellOperation\nfrom prefect import settings\nprefect_api = settings.PREFECT_API_URL.value()\n    # 'http://127.0.0.1:4300/api'\n\n@flow(log_prints=True)\ncall_julia_script(prefect_api_url_arg=prefect_api):\n    result = ShellOperation(\n        stream_output=True\n        , command=[\"julia --project=. --load path/to/julia-script.jl\"]\n        , working_dir=\"path/to/whatever\"\n        , env={\"PREFECT_API_URL\": prefect_api_url_arg}\n        ).run()","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"So you'll pass this to your Docker or ShellOperation either as an env variable or parameter to the julia command.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"For more detailed design discussion, including \"why not PythonCall/JuliaCall\", see Usage and Design Explanation.","category":"page"},{"location":"developers/#Developers","page":"Developers","title":"Developers","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"Develop and test with/without just taskrunner.\nDocumenter.jl doctest() included in runtests.jl","category":"page"},{"location":"developers/#Test,-Build-Docs-with-Justfile","page":"Developers","title":"Test, Build Docs with Justfile","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"note: Note\nAssumes local Prefect test db was installed and running, see Prefect Installation.","category":"page"},{"location":"developers/","page":"Developers","title":"Developers","text":"$ cd ./PrefectInterfaces\n\n$ just build\n\nTest Summary:                 | Pass  Total  Time\nAll tests                     |   95     95  9.0s\n  Config                      |    9      9  0.4s\n  Block types, function tests |   58     58  1.8s\n  Dataset function            |   27     27  0.5s\n  Doctests: PrefectInterfaces |    1      1  5.8s\n\n     Testing PrefectInterfaces tests passed\n\n# docs only: build/doctest\njust docs\n\n# review the docs locally\nopen ./docs/build/index.html","category":"page"},{"location":"developers/#Run-Tests-from-Command-Line","page":"Developers","title":"Run Tests from Command Line","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"# launch the local prefect server if its not available\ncd ./prefect\njust launch\n\ncd ./PrefectInterfaces\njulia --project=. --startup-file=no --eval 'import Pkg; Pkg.test()'\n# SERVER HEALTH CHECK #\n# =================== #\nActive Prefect Environment: main\n┌ Info: Prefect Server must be running, i.e. `prefect server start`\n│ Calling http://127.0.0.1:4300/api/health\n└ Server reponse status: 200 OK\n\nTest Summary:                 | Pass  Total  Time\nAll tests                     |   94     94  2.7s\n  Config                      |    9      9  0.4s\n  Block types, function tests |   58     58  1.8s\n  Dataset function            |   27     27  0.5s\n\n     Testing PrefectInterfaces tests passed","category":"page"},{"location":"developers/#REPL","page":"Developers","title":"REPL","text":"","category":"section"},{"location":"developers/","page":"Developers","title":"Developers","text":"$ julia --project=.","category":"page"},{"location":"developers/","page":"Developers","title":"Developers","text":"pkg> activate .\npkg> test","category":"page"},{"location":"lib/autodoc/","page":"API","title":"API","text":"CurrentModule = PrefectInterfaces\nDocTestSetup = quote\n    using PrefectInterfaces\nend","category":"page"},{"location":"lib/autodoc/#PrefectInterfaces","page":"API","title":"PrefectInterfaces","text":"","category":"section"},{"location":"lib/autodoc/","page":"API","title":"API","text":"Documentation for PrefectInterfaces.","category":"page"},{"location":"lib/autodoc/","page":"API","title":"API","text":"Order = [:module, :type, :function, :constant, :macro]","category":"page"},{"location":"lib/autodoc/#PrefectInterfaces-2","page":"API","title":"PrefectInterfaces","text":"","category":"section"},{"location":"lib/autodoc/","page":"API","title":"API","text":"Modules = [PrefectInterfaces]","category":"page"},{"location":"lib/autodoc/#PrefectInterfaces.PrefectInterfaces","page":"API","title":"PrefectInterfaces.PrefectInterfaces","text":"PrefectInterfaces.jl provides composite types to enable:\n\nInteractive REPL connections to a Prefect server.\nPrefect deployed julia processes that can be called from the python API with parameters.\n\nUse of this package requires a running Prefect server to make connections to the Prefect server REST API, configured with the environment variable PREFECT_API_URL or by specifying the endpoint url in constructor calls. Calling PrefectBlock(blockname::String) retrieves Prefect block information by name, and thus julia modules can be built to connect to resources defined by those blocks.\n\nExamples\n\njulia> using PrefectInterfaces\njulia> ENV[\"PREFECT_API_URL\"] = \"http://127.0.0.1:4300/api\";\n\njulia> ls()\n5-element Vector{Any}:\n \"aws-credentials/subdivisions\"\n \"docker-container/lamneth\"\n \"local-file-system/willowdata\"\n \"process/red-barchetta\"\n \"string/syrinx\"\n\njulia> dump(PrefectBlock(\"local-file-system/willowdata\"))\nPrefectBlock\n  blockname: String \"local-file-system/willowdata\"\n  block: LocalFSBlock\n    blockname: String \"local-file-system/willowdata\"\n    blocktype: String \"local-file-system\"\n    basepath: String \"/Users/mahiki/willowdata/dev\"\n    read_path: #4 (function of type PrefectInterfaces.var\"#4#5\"{String})\n      basepath: String \"/Users/mahiki/willowdata/dev\"\n\n\n\n\n\n","category":"module"},{"location":"lib/autodoc/#PrefectInterfaces.LocalFSBlock","page":"API","title":"PrefectInterfaces.LocalFSBlock","text":"LocalFSBlock(blockname::String, blocktype::String, basepath::String)\n\nCorresponds with the Prefect LocalFileSystem block. Attached functions:\n\nread_path(\"path/to/file.csv\")\nwrite_path(\"path/to/file.csv\", df::AbstractDataFrame)\n\nReturns or writes a DataFrame file at \"LocalFSBlock.basepath/path/to/file.csv\".\n\nExamples:\n\njulia> fsblock = PrefectBlock(\"local-file-system/willowdata\");\n\njulia> df = fsblock.block.read_path(\"extracts/csv/dataset=test_table/rundate=2023-05-25/data.csv\")\n1×2 DataFrame\n Row │ column1                            result\n     │ String                             String7\n─────┼────────────────────────────────────────────\n   1 │ If you can select this table you…  PASSED\n\n\n\n\n\n\n","category":"type"},{"location":"lib/autodoc/#PrefectInterfaces.PrefectAPI","page":"API","title":"PrefectInterfaces.PrefectAPI","text":"PrefectAPI(url::String) <:AbstractPrefectInterface\n\nMutable struct tha stores the Prefect server api endpoint. All PrefectInterface operations depend on connecting to a running Prefect server to pull block information. Constructor with no arguments assigns env variable PREFECT_API_URL to url field.\n\nExamples:\n\njulia> using PrefectInterfaces\n\njulia> ENV[\"PREFECT_API_URL\"] = \"http://127.0.0.1:4300/api\";\n\njulia> api = PrefectAPI()\nPrefectAPI(\"http://127.0.0.1:4300/api\")\n\njulia> api.url\n\"http://127.0.0.1:4300/api\"\n\njulia> api.url = \"http://127.0.0.1:4333/api\"\n\"http://127.0.0.1:4333/api\"\n\njulia> PrefectAPI(\"http://127.0.0.1:4444/api\").url\n\"http://127.0.0.1:4444/api\"\n\n\n\n\n\n","category":"type"},{"location":"lib/autodoc/#PrefectInterfaces.PrefectBlock","page":"API","title":"PrefectInterfaces.PrefectBlock","text":"PrefectBlock <: AbstractPrefectBlock\n\nConstructors:\n\nPrefectBlock(blockname::String)\nPrefectBlock(blockname::String, api_url::String)\nPrefectBlock(blockname::String, block::AbstractPrefectBlock)\n\nReturns a Prefect Block from the Prefect server, the block data is stored in the block field. Prefect Block names are strings called 'slugs', formatted as block-type-name/block-name. A Prefect Block is uniquely specified by its name and the Prefect DB where it is stored, therefore the API URL is necessary for the constructor.\n\nA non-server block can be constructed by supplying an AbstractPrefectBlock object.\n\nThe AbstractPrefectBlock types are meant to mirror the functionality defined in the Prefect Python API, for example LocalFSBlock has a write_path() method attached which only writes to paths relative from the block basepath.\n\nExamples:\n\njulia> using PrefectInterfaces\n\njulia> spec_fsblock = LocalFSBlock(\"local-file-system/xanadu\", \"local-file-system\", \"/usr/mahiki/xanadu/dev\");\n\njulia> fsblock = PrefectBlock(\"local-file-system/xanadu\", spec_fsblock);\n\njulia> dump(fsblock)\nPrefectBlock\n  blockname: String \"local-file-system/xanadu\"\n  block: LocalFSBlock\n    blockname: String \"local-file-system/xanadu\"\n    blocktype: String \"local-file-system\"\n    basepath: String \"/usr/mahiki/xanadu/dev\"\n    read_path: #4 (function of type PrefectInterfaces.var\"#4#6\"{String})\n      basepath: String \"/usr/mahiki/xanadu/dev\"\n    write_path: #5 (function of type PrefectInterfaces.var\"#5#7\"{String})\n      basepath: String \"/usr/mahiki/xanadu/dev\"\n\n\n\n\n\n","category":"type"},{"location":"lib/autodoc/#PrefectInterfaces.SecretString","page":"API","title":"PrefectInterfaces.SecretString","text":"SecretString(secret::String) <:Any\n\nA struct for storing secret values with overrides of show and dump to prevent its field from being exposed in plaintext in logs. The secret field is accessible via the secret field.\n\nNOTE: This is not an ecrypted secrets store, it is a log obfuscator.\n\nExample:\n\njulia> using PrefectInterfaces\n\njulia> password = SecretString(\"abcd1234\")\n####Secret####\n\njulia> show(password)\n####Secret####\njulia> password.secret\n\"abcd1234\"\n\n\n\n\n\n","category":"type"},{"location":"lib/autodoc/#PrefectInterfaces.getblock-Tuple{String}","page":"API","title":"PrefectInterfaces.getblock","text":"getblock(blockname::String; api_url::String=PrefectAPI().url)\n\nMakes an HTTP.get() call to provided URL endpoint, default endpoint constructed by PrefectAPI().url. Returns a Dict containing the Prefect Block specification.\n\n\n\n\n\n","category":"method"},{"location":"lib/autodoc/#PrefectInterfaces.ls-Tuple{}","page":"API","title":"PrefectInterfaces.ls","text":"ls(; type=\"block\", api_url::String=PrefectAPI().url)\n\nCalls the Prefect server and returns a list of all defined blocks as Vector{String}. Default is to list all blocks, later implementation could include \"flows\", \"deployments\", \"work-pool\" etc.\n\nExamples:\n\njulia> ENV[\"PREFECT_API_URL\"] = \"http://127.0.0.1:4300/api\";\n\njulia> ls()\n11-element Vector{Any}:\n \"aws-credentials/subdivisions\"\n \"docker-container/lamneth\"\n \"github/dev\"\n \"github/main\"\n \"local-file-system/willowdata\"\n \"process/red-barchetta\"\n \"s3/necromancer\"\n \"s3-bucket/willowdata\"\n \"secret/necromancer\"\n \"slack-webhook/bytor-alert\"\n \"string/environment\"\n\n\n\n\n\n","category":"method"},{"location":"lib/autodoc/#PrefectInterfaces.makeblock-Tuple{Dict}","page":"API","title":"PrefectInterfaces.makeblock","text":"makeblock(block_api_data::Dict)\n\nInstantiates a new PrefectBlock, choosing the concrete type based on block data returned from the api call for block documents.\n\n\n\n\n\n","category":"method"},{"location":"lib/autodoc/#Datasets","page":"API","title":"Datasets","text":"","category":"section"},{"location":"lib/autodoc/","page":"API","title":"API","text":"Modules = [PrefectInterfaces.Datasets]","category":"page"},{"location":"lib/autodoc/#PrefectInterfaces.Datasets.Dataset","page":"API","title":"PrefectInterfaces.Datasets.Dataset","text":"Dataset(dataset_name=str::String; kwargs...)\n\nAn object that stores configuration, and file path locations. Assertions constrain valid field values. If rundate is not the current date, the latest_path will not be used.\n\nNOTE: No positional arguments allowed b/c of @kw_def, keyworded args only.\n\nSupported keyword arguments (default show first):\n\ndataset_name::String (required)\ndatastore_type ∈ [\"local\", \"remote\"]\ndataset_type ∈ [\"extracts\", \"reports\", \"images\"]\nfile_format ∈ [\"csv\"]\nrundate::Date = Datest.today()\nrundate_type ∈ [\"latest\", \"specific\"]\n\nRead/write behavior depends on rundate/rundate_type combination as follows:\n\nrundate_type|  rundate   || read    |  write\n------------|------------||---------|-----------------------------------------\nlatest      |  == today  || latest  |  [latest, rundate]   default option\nlatest      |  != today  || latest  |  [latest]            dont write to date partition (rare)\nspecific    |  == today  || rundate |  [rundate]\nspecific    |  != today  || rundate |  [rundate]\n\nExamples\n\njulia> begin\n    ENV[\"PREFECT_DATA_BLOCK_LOCAL\"] = \"local-file-system/willowdata\"\n    ENV[\"PREFECT_API_URL\"] = \"http://127.0.0.1:4300/api\"\nend;\n\njulia> ds = Dataset(dataset_name=\"test_table\", datastore_type=\"local\")\nDataset\n  dataset_name: String \"test_table\"\n  datastore_type: String \"local\"\n  dataset_type: String \"extracts\"\n  file_format: String \"csv\"\n  rundate: Dates.Date\n  rundate_type: String \"latest\"\n  dataset_path: String \"extracts/csv/dataset=test_table/rundate=2023-07-24/data.csv\"\n  latest_path: String \"extracts/csv/latest/dataset=test_table/data.csv\"\n  image_path: String \"extracts/dataset=test_table/rundate=2023-07-24\"\n\njulia> df = read(ds)\n1×2 DataFrame\n Row │ column1                            result\n     │ String                             String7\n─────┼────────────────────────────────────────────\n   1 │ If you can select this table you…  PASSED\n\n\n\n\n\n","category":"type"},{"location":"lib/autodoc/#PrefectInterfaces.Datasets.PrefectDatastoreNames","page":"API","title":"PrefectInterfaces.Datasets.PrefectDatastoreNames","text":"PrefectDatastoreNames(remote::String, local::String) <: AbstractPrefectInterface\n\nA struct to store the names of Prefect blocks which reference local and remote file storage. The default constructor pulls the names from ENV variables\n\nPREFECT_DATA_BLOCK_REMOTE\nPREFECT_DATA_BLOCK_LOCAL\n\n\n\n\n\n","category":"type"},{"location":"lib/autodoc/#Base.read-Tuple{Dataset}","page":"API","title":"Base.read","text":"read(ds::Dataset)\n\nReturns a DataFrame by calling CSV.read on a filepath defined by the Dataset type. NOTE: A prefect server must be available.\n\nExamples\n\njulia> begin\n    ENV[\"PREFECT_API_URL\"] = \"http://127.0.0.1:4300/api\"\n    ENV[\"PREFECT_DATA_BLOCK_LOCAL\"] = \"local-file-system/willowdata\"\nend;\n\njulia> df = read(Dataset(dataset_name=\"test_table\", datastore_type=\"local\"))\n1×2 DataFrame\n Row │ column1                            result\n     │ String                             String7\n─────┼────────────────────────────────────────────\n   1 │ If you can select this table you…  PASSED\n\n\n\n\n\n","category":"method"},{"location":"lib/autodoc/#Base.write-Tuple{Dataset, DataFrames.AbstractDataFrame}","page":"API","title":"Base.write","text":"write(ds::Dataset, df::DataFrame)\n\nWrites a DataFrame via CSV.write to a filepath defined by the Dataset type.\n\n\n\n\n\n","category":"method"},{"location":"lib/autodoc/#PrefectInterfaces.Datasets.block_selector-Tuple{Dataset}","page":"API","title":"PrefectInterfaces.Datasets.block_selector","text":"block_selector(ds::Dataset)\n\nReturns the PrefectBlock corresponding to the remote or local datastore type. This block will be used in read/write of dataset paths.\n\n\n\n\n\n","category":"method"}]
}
